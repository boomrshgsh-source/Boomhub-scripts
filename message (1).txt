local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, Mouse, UIS =
    game:GetService("Players"), game:GetService("RunService"),
    workspace.CurrentCamera, game.Players.LocalPlayer, game.Players.LocalPlayer:GetMouse(),
    game:GetService("UserInputService")

local Window = WindUI:CreateWindow({
    Title = "Nexus x dev",
    Icon = "rbxassetid://137877095538630",
    Author = "",
    Folder = "GotHubFolder",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local Tab = Window:Tab({Title = "MANU", Icon = "crosshair"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ตั้งค่า
local SilentAimEnabled = false
local FOV = 350
local PREDICTION_FACTOR = 0.165

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- วง FOV
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.new(1,1,1)
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- เส้น Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.new(1,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

-- หาเป้าหมายใกล้สุด
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOV and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Prediction
local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

-- ตรวจสอบปืน
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then
        return true
    end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- Hook FireServer
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        local target = GetClosestTarget()
        if target and target.Character and target.Character:FindFirstChild("Head") then
            local head = target.Character.Head
            local aimPos = PredictPosition(head)
            args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
        end
    end
    return oldFire(self, unpack(args))
end)

-- Update วง FOV และ Tracer ทุกเฟรม
RunService.RenderStepped:Connect(function()
    if not fovCircle then return end
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = math.clamp(FOV, 50, 1000) -- ป้องกันค่าเกิน

    if not SilentAimEnabled then
        fovCircle.Visible = false
        tracerLine.Visible = false
        return
    end

    fovCircle.Visible = true
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local predictedPos = PredictPosition(target.Character.Head)
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            local ourHeadPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
            if ourHeadPos then
                local screenStart, startOnScreen = Camera:WorldToViewportPoint(ourHeadPos)
                if startOnScreen then
                    tracerLine.From = Vector2.new(screenStart.X, screenStart.Y)
                    tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                    tracerLine.Visible = true
                else
                    tracerLine.Visible = false
                end
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- Toggle UI
Tab:Toggle({
    Title = "Enable Silent Aim",
    Desc = "",
    Value = false,
    Callback = function(v)
        SilentAimEnabled = v
        fovCircle.Visible = v
        tracerLine.Visible = v
        print("[SilentAim]:", v and "Enabled" or "Disabled")
    end
})

-- Slider FOV
Tab:Slider({
    Title = "FOV",
    Desc = "",
    Step = 1,
    Value = {
        Min = 50,
        Max = 1000,
        Default = FOV,
    },
    Callback = function(value)
        FOV = math.clamp(value, 50, 1000) -- ป้องกันค่าเกิน
        if fovCircle then
            fovCircle.Radius = FOV
        end
        print("[SilentAim] FOV set to:", FOV)
    end
})
    -- ==========================================
-- SERVICES
-- ==========================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- ==========================================
-- CONFIG
-- ==========================================
local SilentAimAttachEnabled = false
local WallbangEnabled = false
local FOVRadius = 140
local PredictionMultiplier = 5
local TargetPartName = "Head"
local CurrentTarget = nil

-- ==========================================
-- HEART UI (TARGET LOCK INDICATOR)
-- ==========================================
local Heart = Drawing.new("Text")
Heart.Text = "♥"
Heart.Size = 42
Heart.Center = true
Heart.Outline = true
Heart.Color = Color3.fromRGB(255, 40, 40)
Heart.Visible = false

-- ==========================================
-- ROTATING MARKS (4 LINES AROUND HEART)
-- ==========================================
local marks = {}
local spinRadius = 55
local spinSpeed = 2.5

for i = 1, 4 do
    local line = Drawing.new("Line")
    line.Thickness = 4
    line.Color = Color3.fromRGB(0,0,0)
    line.Visible = false
    marks[i] = line
end

-- SPIN AROUND TARGET HEAD
task.spawn(function()
    local angle = 0
    while true do
        angle = angle + spinSpeed

        if SilentAimAttachEnabled and CurrentTarget and CurrentTarget.Character then
            local head = CurrentTarget.Character:FindFirstChild("Head")
            if head then
                local v3, onScreen = Camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    local hx, hy = v3.X, v3.Y

                    -- Heart follow head
                    Heart.Position = Vector2.new(hx, hy)
                    Heart.Visible = true

                    -- 4 rotating marks
                    for i, v in ipairs(marks) do
                        local theta = math.rad(angle + (i-1)*90)
                        local x = hx + math.cos(theta) * spinRadius
                        local y = hy + math.sin(theta) * spinRadius
                        v.From = Vector2.new(x, y)
                        v.To   = Vector2.new(hx + math.cos(theta)*15, hy + math.sin(theta)*15)
                        v.Visible = true
                    end
                else
                    Heart.Visible = false
                    for _,v in ipairs(marks) do v.Visible = false end
                end
            end
        else
            Heart.Visible = false
            for _,v in ipairs(marks) do v.Visible = false end
        end

        task.wait()
    end
end)

-- ==========================================
-- LOCK LINE FROM OUR HEAD → TARGET HEAD
-- ==========================================
local LockLine = Drawing.new("Line")
LockLine.Thickness = 2.5
LockLine.Color = Color3.fromRGB(255, 60, 60)
LockLine.Visible = false

-- ==========================================
-- FOV CIRCLE
-- ==========================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.Filled = false
FOVCircle.NumSides = 120
FOVCircle.Transparency = 1
FOVCircle.Radius = FOVRadius

task.spawn(function()
    local hue = 0
    while true do
        hue = (hue + 1) % 255
        FOVCircle.Color = Color3.fromRGB(255, hue/2, hue/4)
        task.wait(0.02)
    end
end)

-- ==========================================
-- UI UPDATER
-- ==========================================
RunService.RenderStepped:Connect(function()
    local cx, cy = Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2

    -- FOV always center
    FOVCircle.Position = Vector2.new(cx, cy)
    FOVCircle.Radius = FOVRadius

    -- Update lock line
    if SilentAimAttachEnabled and CurrentTarget and CurrentTarget.Character then
        local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
        local targetHead = CurrentTarget.Character:FindFirstChild("Head")

        if myHead and targetHead then
            local a, on1 = Camera:WorldToViewportPoint(myHead.Position)
            local b, on2 = Camera:WorldToViewportPoint(targetHead.Position)

            if on1 and on2 then
                LockLine.Visible = true
                LockLine.From = Vector2.new(a.X, a.Y)
                LockLine.To   = Vector2.new(b.X, b.Y)
            else
                LockLine.Visible = false
            end
        else
            LockLine.Visible = false
        end
    else
        LockLine.Visible = false
    end
end)

-- ==========================================
-- PING (STATIC)
-- ==========================================
local function getPing()
    return 0.18
end

-- ==========================================
-- PREDICTION
-- ==========================================
local function predictPosition(part, hrp)
    return part.Position + hrp.Velocity * getPing() * PredictionMultiplier
end

-- ==========================================
-- GET TARGET PART
-- ==========================================
local function getAimPart(char)
    return char:FindFirstChild(TargetPartName)
end

-- ==========================================
-- FIND CLOSEST TARGET INSIDE FOV
-- ==========================================
local function getClosestTarget()
    local closest = nil
    local shortest = FOVRadius
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local part = getAimPart(plr.Character)
            local hum = plr.Character:FindFirstChild("Humanoid")
            if part and hum and hum.Health > 0 then
                local v3, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(v3.X,v3.Y) - center).Magnitude
                    if dist <= FOVRadius and dist < shortest then
                        closest = plr
                        shortest = dist
                    end
                end
            end
        end
    end

    return closest
end

-- UPDATE TARGET FREQUENCY
RunService.RenderStepped:Connect(function()
    if SilentAimAttachEnabled then
        CurrentTarget = getClosestTarget()
    end
end)

-- ==========================================
-- WALL CHECK
-- ==========================================
local function isBehindWall(startPos, endPos)
    local ray = Ray.new(startPos, endPos - startPos)
    local ignore = {LocalPlayer.Character}

    if CurrentTarget and CurrentTarget.Character then
        table.insert(ignore, CurrentTarget.Character)
    end

    return Workspace:FindPartOnRayWithIgnoreList(ray, ignore)
end

-- ==========================================
-- HOOK REMOTE (SEND)
-- ==========================================
local Remote
pcall(function()
    Remote = game.ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
end)

if Remote then
    local old
    old = hookfunction(Remote.FireServer, function(self, ...)
        if self ~= Remote then
            return old(self, ...)
        end

        local args = {...}

        if (SilentAimAttachEnabled or WallbangEnabled)
        and args[2] == "shoot_gun"
        and CurrentTarget then

            local char = CurrentTarget.Character
            local part = getAimPart(char)
            local hrp = char:FindFirstChild("HumanoidRootPart")

            if part and hrp then
                local myHead = LocalPlayer.Character.Head
                local aimPos = predictPosition(part, hrp)
                local blocked = isBehindWall(myHead.Position, aimPos)

                if WallbangEnabled and blocked then
                    args[4] = CFrame.new(9e9,9e9,9e9)
                else
                    args[4] = CFrame.new(myHead.Position, aimPos)
                end

                args[5] = {
                    [1] = {
                        [1] = {
                            ["Instance"] = part,
                            ["Normal"] = Vector3.new(0, 1, 0),
                            ["Position"] = aimPos
                        }
                    }
                }
            end
        end

        return old(self, unpack(args))
    end)
end

-- ==========================================
-- WINDUI – MAIN TAB
-- ==========================================

Tab:Toggle({
    Title = "Silent Aim Attach",
    Desc = "ล็อกเป้าอัตโนมัติ",
    Default = false,
    Callback = function(state)
        SilentAimAttachEnabled = state
        Heart.Visible = state
        FOVCircle.Visible = state
        for _,v in ipairs(marks) do v.Visible = state end
        if state then WallbangEnabled = false end
    end
})

Tab:Toggle({
    Title = "Wallbang",
    Desc = "ยิงทะลุกำแพง",
    Default = false,
    Callback = function(state)
        WallbangEnabled = state
        if state then
            SilentAimAttachEnabled = false
            Heart.Visible = false
            FOVCircle.Visible = false
            for _,v in ipairs(marks) do v.Visible = false end
        end
    end
})

Tab:Slider({
    Title = "FOV Size",
    Desc = "ขนาดวงล็อกเป้า",
    Default = FOVRadius,
    Min = 50,
    Max = 450,
    Callback = function(v)
        FOVRadius = v
    end
})

Tab:Dropdown({
    Title = "Aim Part",
    Desc = "เลือกจุดล็อกเป้า",
    Items = {"Head","HumanoidRootPart"},
    Default = "Head",
    Callback = function(part)
        TargetPartName = part
    end
})
