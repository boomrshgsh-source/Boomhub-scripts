local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, Mouse, UIS =
    game:GetService("Players"), game:GetService("RunService"),
    workspace.CurrentCamera, game.Players.LocalPlayer, game.Players.LocalPlayer:GetMouse(),
    game:GetService("UserInputService")

local Window = WindUI:CreateWindow({
    Title = "Nexus x dev",
    Icon = "rbxassetid://137877095538630",
    Author = "",
    Folder = "GotHubFolder",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local Tab = Window:Tab({Title = "MANU", Icon = "crosshair"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ตั้งค่า
local SilentAimEnabled = false
local FOV = 350
local PREDICTION_FACTOR = 0.165

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- วง FOV
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.new(1,1,1)
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- เส้น Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.new(1,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

-- หาเป้าหมายใกล้สุด
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOV and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Prediction
local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

-- ตรวจสอบปืน
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then
        return true
    end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- Hook FireServer
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        local target = GetClosestTarget()
        if target and target.Character and target.Character:FindFirstChild("Head") then
            local head = target.Character.Head
            local aimPos = PredictPosition(head)
            args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
        end
    end
    return oldFire(self, unpack(args))
end)

-- Update วง FOV และ Tracer ทุกเฟรม
RunService.RenderStepped:Connect(function()
    if not fovCircle then return end
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = math.clamp(FOV, 50, 1000) -- ป้องกันค่าเกิน

    if not SilentAimEnabled then
        fovCircle.Visible = false
        tracerLine.Visible = false
        return
    end

    fovCircle.Visible = true
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local predictedPos = PredictPosition(target.Character.Head)
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            local ourHeadPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
            if ourHeadPos then
                local screenStart, startOnScreen = Camera:WorldToViewportPoint(ourHeadPos)
                if startOnScreen then
                    tracerLine.From = Vector2.new(screenStart.X, screenStart.Y)
                    tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                    tracerLine.Visible = true
                else
                    tracerLine.Visible = false
                end
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- Toggle UI
Tab:Toggle({
    Title = "Enable Silent Aim",
    Desc = "",
    Value = false,
    Callback = function(v)
        SilentAimEnabled = v
        fovCircle.Visible = v
        tracerLine.Visible = v
        print("[SilentAim]:", v and "Enabled" or "Disabled")
    end
})

-- Slider FOV
Tab:Slider({
    Title = "FOV",
    Desc = "",
    Step = 1,
    Value = {
        Min = 50,
        Max = 1000,
        Default = FOV,
    },
    Callback = function(value)
        FOV = math.clamp(value, 50, 1000) -- ป้องกันค่าเกิน
        if fovCircle then
            fovCircle.Radius = FOV
        end
        print("[SilentAim] FOV set to:", FOV)
    end
})


------------------------------
--  SILENT AIM FULL PACKAGE --
--     TAB NAME:  TEST      --
------------------------------

--== SERVICES ==--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

--== VARIABLES ==--
local SilentAimEnabled = false
local WallbangEnabled = false
local FOVRadius = 150
local CurrentTarget = nil

--== DRAWINGS ==--
local FOVCircle = Drawing.new("Circle")
FOVCircle.Filled = false
FOVCircle.NumSides = 100
FOVCircle.Thickness = 2
FOVCircle.Visible = false

local Tracer = Drawing.new("Line")
Tracer.Thickness = 1
Tracer.Visible = false

local TargetRing = Drawing.new("Circle")
TargetRing.Radius = 45
TargetRing.Filled = false
TargetRing.Thickness = 2
TargetRing.Visible = false
TargetRing.NumSides = 50

--------------------------------------------------------
--== ADVANCED PREDICTION + ANTI AIM BREAKER ==--
--------------------------------------------------------
local function getTrueVelocity(hrp)
    if not hrp then return Vector3.zero end
    local vel = hrp.Velocity
    if vel.Magnitude > 180 then  -- anti aim breaker
        vel = vel.Unit * 180
    end
    return vel
end

local function getAcceleration(hrp)
    if not hrp then return Vector3.zero end
    local last = hrp:GetAttribute("_lastVel") or Vector3.zero
    local now = hrp.Velocity
    hrp:SetAttribute("_lastVel", now)
    return (now - last) * 0.15
end

local function superPredict(head, hrp)
    if not head or not hrp then return head.Position end

    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    if ping <= 0 then ping = 0.12 end

    local vel = getTrueVelocity(hrp)
    local accel = getAcceleration(hrp)
    local jumpBoost = Vector3.new(0, math.clamp(vel.Y, -18, 28) * ping, 0)

    return head.Position + (vel * ping * 1.4) + (accel * ping * 1.1) + jumpBoost
end

local function breakAntiAim(player)
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if hrp.AssemblyAngularVelocity.Magnitude > 18 then
        local vel = hrp.Velocity
        if vel.Magnitude > 2 then
            hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + vel)
        end
    end
end

--------------------------------------------------------
--== FIND TARGET INSIDE FOV ==--
--------------------------------------------------------
local function getClosestTarget()
    local closest, shortest = nil, FOVRadius
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _,plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            local head = plr.Character.Head
            local pos, visible = Camera:WorldToViewportPoint(head.Position)
            if visible then
                local dist = (Vector2.new(pos.X, pos.Y) - center).Magnitude
                if dist <= shortest then
                    shortest = dist
                    closest = plr
                end
            end
        end
    end

    return closest
end

--------------------------------------------------------
--== WALL CHECK ==--
--------------------------------------------------------
local function behindWall(from, to)
    local ray = Ray.new(from, (to - from))
    local ignore = {LocalPlayer.Character}
    local hit = Workspace:FindPartOnRayWithIgnoreList(ray, ignore)
    return hit ~= nil
end

--------------------------------------------------------
--== HOOK SHOOT EVENT ==--
--------------------------------------------------------
local Remote = game.ReplicatedStorage:WaitForChild("Remotes").Send
local old; old = hookfunction(Remote.FireServer, function(self, ...)
    local args = {...}

    if self == Remote and args[2] == "shoot_gun" and CurrentTarget then
        breakAntiAim(CurrentTarget)

        local head = CurrentTarget.Character.Head
        local hrp = CurrentTarget.Character.HumanoidRootPart
        local myHead = LocalPlayer.Character.Head
        local aimPos = superPredict(head, hrp)

        if WallbangEnabled and behindWall(myHead.Position, aimPos) then
            args[4] = CFrame.new(math.huge, math.huge, math.huge)
        else
            args[4] = CFrame.new(myHead.Position, aimPos)
        end

        args[5] = {
            {
                {
                    Instance = head,
                    Normal = Vector3.new(0, 1, 0),
                    Position = aimPos
                }
            }
        }
    end

    return old(self, unpack(args))
end)

--------------------------------------------------------
--== RENDER VISUALS (FOV + TRACER + TARGET RING) ==--
--------------------------------------------------------
local hueF = 0
local hueT = 0

RunService.RenderStepped:Connect(function()
    -- FOV Circle Gradient
    hueF = (hueF + 0.008) % 1
    local purple = 0.78
    local pink = 0.9
    local gradientF = purple + (pink - purple) * math.abs(math.sin(hueF * math.pi))

    FOVCircle.Color = Color3.fromHSV(gradientF,1,1)
    FOVCircle.Visible = SilentAimEnabled
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    FOVCircle.Radius = FOVRadius

    -- Update target
    CurrentTarget = SilentAimEnabled and getClosestTarget() or nil

    if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
        local head = CurrentTarget.Character.Head
        local hrp = CurrentTarget.Character.HumanoidRootPart
        local headPos, visible = Camera:WorldToViewportPoint(head.Position)

        if visible then
            -- TRACER
            Tracer.Visible = true
            Tracer.Color = Color3.fromHSV(gradientF,1,1)
            Tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            Tracer.To = Vector2.new(headPos.X, headPos.Y)

            -- TARGET RING
            hueT = (hueT + 0.01) % 1
            local gradientT = purple + (pink - purple) * math.abs(math.sin(hueT * math.pi))
            TargetRing.Color = Color3.fromHSV(gradientT,1,1)

            TargetRing.Visible = true
            TargetRing.Position = Vector2.new(headPos.X, headPos.Y)

        else
            Tracer.Visible = false
            TargetRing.Visible = false
        end
    else
        Tracer.Visible = false
        TargetRing.Visible = false
    end
end)

--------------------------------------------------------
--== WINDUI TAB + CONTROLS ==--
-------------------------------------------------------


local Tab_Test = Window:Tab({Title = "Test", Icon = "crosshair"})

Tab_Test:Toggle({
    Title = "Silent Aim",
    Default = false,
    Callback = function(v)
        SilentAimEnabled = v
    end
})

Tab_Test:Toggle({
    Title = "Wallbang (GoodGun)",
    Default = false,
    Callback = function(v)
        WallbangEnabled = v
    end
})

Tab_Test:Slider({
    Title = "FOV Size",
    Min = 30,
    Max = 300,
    Default = 150,
    Callback = function(v)
        FOVRadius = v
    end
})
