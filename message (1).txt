local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, Mouse, UIS =
    game:GetService("Players"), game:GetService("RunService"),
    workspace.CurrentCamera, game.Players.LocalPlayer, game.Players.LocalPlayer:GetMouse(),
    game:GetService("UserInputService")

local Window = WindUI:CreateWindow({
    Title = "Nexus x dev",
    Icon = "rbxassetid://137877095538630",
    Author = "",
    Folder = "GotHubFolder",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local Tab = Window:Tab({Title = "MANU", Icon = "crosshair"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ตั้งค่า
local SilentAimEnabled = false
local FOV = 350
local PREDICTION_FACTOR = 0.165

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- วง FOV
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.new(1,1,1)
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- เส้น Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.new(1,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

-- หาเป้าหมายใกล้สุด
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOV and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Prediction
local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

-- ตรวจสอบปืน
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then
        return true
    end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- Hook FireServer
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        local target = GetClosestTarget()
        if target and target.Character and target.Character:FindFirstChild("Head") then
            local head = target.Character.Head
            local aimPos = PredictPosition(head)
            args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
        end
    end
    return oldFire(self, unpack(args))
end)

-- Update วง FOV และ Tracer ทุกเฟรม
RunService.RenderStepped:Connect(function()
    if not fovCircle then return end
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = math.clamp(FOV, 50, 1000) -- ป้องกันค่าเกิน

    if not SilentAimEnabled then
        fovCircle.Visible = false
        tracerLine.Visible = false
        return
    end

    fovCircle.Visible = true
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local predictedPos = PredictPosition(target.Character.Head)
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            local ourHeadPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
            if ourHeadPos then
                local screenStart, startOnScreen = Camera:WorldToViewportPoint(ourHeadPos)
                if startOnScreen then
                    tracerLine.From = Vector2.new(screenStart.X, screenStart.Y)
                    tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                    tracerLine.Visible = true
                else
                    tracerLine.Visible = false
                end
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- Toggle UI
Tab:Toggle({
    Title = "Enable Silent Aim",
    Desc = "",
    Value = false,
    Callback = function(v)
        SilentAimEnabled = v
        fovCircle.Visible = v
        tracerLine.Visible = v
        print("[SilentAim]:", v and "Enabled" or "Disabled")
    end
})

-- Slider FOV
Tab:Slider({
    Title = "FOV",
    Desc = "",
    Step = 1,
    Value = {
        Min = 50,
        Max = 1000,
        Default = FOV,
    },
    Callback = function(value)
        FOV = math.clamp(value, 50, 1000) -- ป้องกันค่าเกิน
        if fovCircle then
            fovCircle.Radius = FOV
        end
        print("[SilentAim] FOV set to:", FOV)
    end
})

--== SERVICES ==--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

--== CONFIG ==--
local SilentAimEnabled = false
local FOVEnabled = false
local FOVRadius = 120
local PredictionAmount = 0.125

--== UI CONTAINER ==--
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.IgnoreGuiInset = true

--== FOV CIRCLE ==--
local FOV = Instance.new("Frame")
FOV.Size = UDim2.fromOffset(FOVRadius * 2, FOVRadius * 2)
FOV.AnchorPoint = Vector2.new(0.5, 0.5)
FOV.Position = UDim2.fromScale(0.5, 0.5)
FOV.BackgroundTransparency = 1
FOV.Visible = false
FOV.Parent = ScreenGui

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 3
UIStroke.Color = Color3.fromRGB(255, 0, 255)
UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
UIStroke.Parent = FOV

--== DRAWING OBJECTS ==--
local Tracer = Drawing.new("Line")
Tracer.Thickness = 2
Tracer.Visible = false

local Heart = Drawing.new("Text")
Heart.Size = 28
Heart.Center = true
Heart.Outline = true
Heart.Visible = false
Heart.Text = "❤"

--== FUNCTION: Find target in FOV ==--
local function GetTarget()
    local closest, distance = nil, FOVRadius

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and
           plr.Character and
           plr.Character:FindFirstChild("HumanoidRootPart") then

            local pos, onScreen = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
            if onScreen then
                local dist = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if dist < distance then
                    distance = dist
                    closest = plr
                end
            end
        end
    end

    return closest
end

--== PREDICTION LOGIC ==--
local function PredictPosition(target)
    local hrp = target.Character.HumanoidRootPart
    return hrp.Position + hrp.Velocity * PredictionAmount
end

--== MAIN VISUAL LOOP ==--
RunService.RenderStepped:Connect(function()
    local t = tick() * 2
    UIStroke.Color = Color3.fromHSV((t % 1), 1, 1)

    FOV.Size = UDim2.fromOffset(FOVRadius * 2, FOVRadius * 2)
    FOV.Visible = SilentAimEnabled and FOVEnabled

    local target = nil
    if SilentAimEnabled then
        target = GetTarget()
    end

    if not target or not FOV.Visible then
        Tracer.Visible = false
        Heart.Visible = false
        return
    end

    local predicted = PredictPosition(target)
    local screenPos, onScreen = Camera:WorldToViewportPoint(predicted)

    if onScreen then
        Tracer.Visible = true
        Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        Tracer.Color = Color3.fromHSV((t % 1), 1, 1)

        Heart.Visible = true
        Heart.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
        Heart.Color = Color3.fromHSV((t % 1), 1, 1)
    else
        Tracer.Visible = false
        Heart.Visible = false
    end
end)

--== SILENT AIM HOOK ==--
local mt = getrawmetatable(game)
setreadonly(mt, false)

local old = mt.__namecall
mt.__namecall = function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if SilentAimEnabled and method == "FireServer" and tostring(self) == "UpdateMousePos" then
        local target = GetTarget()
        if target then
            args[1] = PredictPosition(target)
            return old(self, unpack(args))
        end
    end

    return old(self, ...)
end

--== TOGGLE FUNCTIONS ==--
function ToggleSilent(v)
    SilentAimEnabled = v
    FOV.Visible = SilentAimEnabled and FOVEnabled
end

function ToggleFOV(v)
    FOVEnabled = v
    FOV.Visible = SilentAimEnabled and FOVEnabled
end

function SetFOVSize(v)
    FOVRadius = v
end

-----------------------------------------------------------------
--== WIND UI ==--
-----------------------------------------------------------------


local AimTab = Window:Tab({Title = "Aimbot", Icon = "crosshair"})

AimTab:Toggle({
    Title = "Silent Aim",
    Default = false,
    Callback = function(v)
        ToggleSilent(v)
    end
})

AimTab:Toggle({
    Title = "FOV + Tracer + Heart",
    Default = false,
    Callback = function(v)
        ToggleFOV(v)
    end
})

AimTab:Slider({
    Title = "FOV Size",
    Min = 20,
    Max = 300,
    Default = 120,
    Callback = function(val)
        SetFOVSize(val)
    end
})


