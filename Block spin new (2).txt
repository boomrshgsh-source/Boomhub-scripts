local WEBHOOK_URL = "https://discord.com/api/webhooks/1447146865979031583/VrS18OLAQGDAEKaQdaVuVSPS-ugw_mDImZxnmENLVeDFMdUMVoj_Zo6MXugoY0coHuYT"

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Marketplace = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

local plr = Players.LocalPlayer

local function GetOS()
    local platform = UserInputService:GetPlatform()
    if platform == Enum.Platform.Windows then
        return "Windows üíª"
    elseif platform == Enum.Platform.IOS then
        return "iOS üçé"
    elseif platform == Enum.Platform.Android then
        return "Android ü§ñ"
    else
        return "Unknown"
    end
end
local OS = GetOS()

local executorName, executorVersion = "Unknown", ""
pcall(function()
    if identifyexecutor then
        local n, v = identifyexecutor()
        executorName = n or "Unknown"
        executorVersion = v or ""
    end
end)
local ExecutorText = executorName
if executorVersion ~= "" then
    ExecutorText = ExecutorText .. " | " .. executorVersion
end

local avatarApi = "https://thumbnails.roblox.com/v1/users/avatar?userIds=" ..
    plr.UserId .. "&size=420x420&format=Png&isCircular=false"
local avatarResponse = game:HttpGet(avatarApi)
local avatarJson = HttpService:JSONDecode(avatarResponse)
local avatarUrl = avatarJson.data[1].imageUrl or ""

local mapApi = "https://thumbnails.roblox.com/v1/places/gameicons?placeIds=" ..
    game.PlaceId .. "&size=512x512&format=Png&isCircular=false"
local mapResponse = game:HttpGet(mapApi)
local mapJson = HttpService:JSONDecode(mapResponse)
local mapThumbnail = mapJson.data[1].imageUrl or ""

local placeId = game.PlaceId
local placeName = Marketplace:GetProductInfo(placeId).Name

local placeLink = "https://www.roblox.com/games/"..placeId

local function GetThaiTimestamp()
    local time = os.date("!*t")
    time.hour = (time.hour + 7) % 24
    return string.format("%02d-%02d-%02d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
end
local timestamp = GetThaiTimestamp()

local color = 0
if OS == "Windows üíª" then
    color = 3447003
elseif OS == "Android ü§ñ" then
    color = 3066993
elseif OS == "iOS üçé" then
    color = 15158332
else
    color = 0
end

local data = {
    username = "ERROR HUB",
    embeds = {{
        title = "üååERROR HUB Block spin new ",
        color = color,
        thumbnail = { url = avatarUrl },
        image = { url = mapThumbnail },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        fields = {
            { name = "üå† ‡∏Ñ‡∏ô‡πÉ‡∏ä‡πâ", value = plr.Name, inline = true },
            { name = "üì± ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ", value = OS, inline = true },
            { name = "üß∞ Executor", value = ExecutorText, inline = false },
            { name = "üåç ‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏°‡∏û", value = "["..placeName.."]("..placeLink..")", inline = false },
            { name = "üÜî JobId", value = tostring(game.JobId), inline = false },
            { name = "üïí ‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ô", value = timestamp, inline = false }
        }
    }}
}

local body = HttpService:JSONEncode(data)

qrequest({
    Url = WEBHOOK_URL,
    Method = "POST",
    Headers = { ["Content-Type"] = "application/json" },
    Body = body
})

-- =========================
-- Services
-- =========================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")

-- =========================
-- Local Variables
-- =========================
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- =========================
-- Excluded Players / Safe Friend List
-- =========================
local excludedPlayerNames = {"MithnoFs_49"}
local excludedPlayersUI = {}

-- =========================
-- Load WindUI
-- =========================
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- =========================
-- Window UI
-- =========================
local Window = WindUI:CreateWindow({
    Title = "ERROR HUB | Silent Aim",
    Icon = "",
    Author = "",
    Folder = "ERROR HUB",
    Size = UDim2.fromOffset(450, 330),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

-- =========================
-- Config Manager (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤)
-- =========================
local ConfigManager = Window.ConfigManager
local myConfig = ConfigManager:CreateConfig("SilentAimConfig")

-- =========================
-- Silent Aim Variables
-- =========================
local SilentAimEnabled = false
local ShowFOV = true
local FOV = 120
local SilentFOVCircle
local tracerLine, targetDot

-- =========================
-- Utility Functions
-- =========================
local function isPlayerExcluded(playerName)
    local lowerPlayerName = string.lower(playerName)
    for _, excludedName in ipairs(excludedPlayerNames) do
        if excludedName ~= "" and string.find(lowerPlayerName, string.lower(excludedName)) then
            return true
        end
    end
    return false
end

local function UpdateExcludedHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if isPlayerExcluded(player.Name) and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not excludedPlayersUI[player] then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(0, 255, 0)
                highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                highlight.FillTransparency = 0.3
                highlight.OutlineTransparency = 0
                highlight.Parent = player.Character
                excludedPlayersUI[player] = highlight
            end
        else
            if excludedPlayersUI[player] then
                excludedPlayersUI[player]:Destroy()
                excludedPlayersUI[player] = nil
            end
        end
    end
end

-- =========================
-- FOV Circle Creation
-- =========================
local function CreateFOVCircle()
    if not isMobile then
        if SilentFOVCircle then SilentFOVCircle:Remove() end
        SilentFOVCircle = Drawing.new("Circle")
        SilentFOVCircle.Color = Color3.fromRGB(255, 255, 255)
        SilentFOVCircle.Thickness = 2
        SilentFOVCircle.NumSides = 64
        SilentFOVCircle.Filled = false
        SilentFOVCircle.Transparency = 0.8
        SilentFOVCircle.Radius = FOV
        SilentFOVCircle.Visible = SilentAimEnabled and ShowFOV
    else
        if SilentFOVCircle and SilentFOVCircle.Parent then SilentFOVCircle.Parent:Destroy() end
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MobileFOV"
        ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
        
        SilentFOVCircle = Instance.new("Frame")
        SilentFOVCircle.Size = UDim2.fromOffset(FOV * 2, FOV * 2)
        SilentFOVCircle.AnchorPoint = Vector2.new(0.5, 0.5)
        SilentFOVCircle.Position = UDim2.fromScale(0.5, 0.5)
        SilentFOVCircle.BackgroundTransparency = 1
        
        local circleUI = Instance.new("UICorner")
        circleUI.CornerRadius = UDim.new(1, 0)
        circleUI.Parent = SilentFOVCircle
        
        local border = Instance.new("UIStroke")
        border.Color = Color3.fromRGB(255, 255, 255)
        border.Thickness = 2
        border.Transparency = 0.2
        border.Parent = SilentFOVCircle
        
        SilentFOVCircle.Parent = ScreenGui
    end
end

-- =========================
-- Drawing Objects
-- =========================
local function CreateDrawingObjects()
    if tracerLine then tracerLine:Remove() end
    if targetDot then targetDot:Remove() end
    
    tracerLine = Drawing.new("Line")
    tracerLine.Color = Color3.fromRGB(255, 50, 50)
    tracerLine.Thickness = 1
    tracerLine.Transparency = 1
    tracerLine.Visible = false
    
    targetDot = Drawing.new("Circle")
    targetDot.Color = Color3.fromRGB(255, 50, 50)
    targetDot.Thickness = 2
    targetDot.NumSides = 12
    targetDot.Radius = 4
    targetDot.Filled = true
    targetDot.Transparency = 0.7
    targetDot.Visible = false
end

-- =========================
-- Target Selection
-- =========================
local function GetClosestTarget()
    local closest = nil
    local shortestDistance = FOV
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            
            if head and humanoid and humanoid.Health > 0 and hrp then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenVector = Vector2.new(screenPos.X, screenPos.Y)
                    local distanceFromCenter = (screenVector - center).Magnitude
                    
                    if distanceFromCenter <= FOV and not isPlayerExcluded(player.Name) then
                        if distanceFromCenter < shortestDistance then
                            shortestDistance = distanceFromCenter
                            closest = player
                        end
                    end
                end
            end
        end
    end
    return closest
end

local function SimplePredictPosition(head, hrp)
    local velocity = hrp and hrp.Velocity or Vector3.zero
    return head.Position + (velocity * 0.15)
end

-- =========================
-- Remote Hook (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤)
-- =========================
local Remote
pcall(function()
    Remote = ReplicatedStorage:WaitForChild("Remotes", 5):WaitForChild("Send", 5)
end)

local oldFire
if Remote and Remote.FireServer then
    local ok, res = pcall(function()
        oldFire = hookfunction(Remote.FireServer, function(self, ...)
            if self ~= Remote then return oldFire(self, ...) end
            local args = {...}
            
            if SilentAimEnabled and args[2] == "shoot_gun" then
                local target = GetClosestTarget()
                if target and target.Character then
                    local head = target.Character:FindFirstChild("Head")
                    local hrp = target.Character:FindFirstChild("HumanoidRootPart")
                    local humanoid = target.Character:FindFirstChild("Humanoid")
                    
                    if head and humanoid and humanoid.Health > 0 and hrp then
                        local aimPos = SimplePredictPosition(head, hrp)
                        local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                        
                        if myHead then
                            args[4] = CFrame.new(
                                1/0, 1/0, 1/0,
                                0/0, 0/0, 0/0,
                                0/0, 0/0, 0/0,
                                0/0, 0/0, 0/0
                            )
                            
                            args[5] = {
                                [1] = {
                                    [1] = {
                                        ["Instance"] = head,
                                        ["Position"] = aimPos
                                    }
                                }
                            }
                        end
                    end
                end
            end
            
            return oldFire(self, unpack(args))
        end)
    end)
    
    if not ok then
        warn("Warning: Failed to hook Remote.FireServer")
    end
end

-- =========================
-- Main Render Loop
-- =========================
RunService.RenderStepped:Connect(function()
    pcall(function()
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        -- Update FOV Circle
        if SilentFOVCircle then
            if not isMobile then
                SilentFOVCircle.Position = center
                SilentFOVCircle.Radius = FOV
            end
            SilentFOVCircle.Visible = ShowFOV and (SilentAimEnabled)
        end
        
        -- Update Excluded Player Highlights
        UpdateExcludedHighlights()
        
        if not SilentAimEnabled then
            if tracerLine then tracerLine.Visible = false end
            if targetDot then targetDot.Visible = false end
            return
        end
        
        local target = GetClosestTarget()
        if target and target.Character then
            local head = target.Character:FindFirstChild("Head")
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = target.Character:FindFirstChild("Humanoid")
            
            if head and humanoid and humanoid.Health > 0 and hrp then
                local aimPos = SimplePredictPosition(head, hrp)
                local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)
                
                if onScreen then
                    if tracerLine then
                        tracerLine.Visible = true
                        tracerLine.From = center
                        tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                        tracerLine.Color = Color3.fromRGB(255, 50, 50)
                    end
                    
                    if targetDot then
                        targetDot.Visible = true
                        targetDot.Position = Vector2.new(screenPos.X, screenPos.Y)
                    end
                else
                    if tracerLine then tracerLine.Visible = false end
                    if targetDot then targetDot.Visible = false end
                end
            else
                if tracerLine then tracerLine.Visible = false end
                if targetDot then targetDot.Visible = false end
            end
        else
            if tracerLine then tracerLine.Visible = false end
            if targetDot then targetDot.Visible = false end
        end
    end)
end)

-- =========================
-- Initial Setup
-- =======================
CreateFOVCircle()
CreateDrawingObjects()

LocalPlayer.CharacterAdded:Connect(function()
    wait(0.1)
    CreateFOVCircle()
    CreateDrawingObjects()
end)

-- =========================
-- UI Creation (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏£)
-- =========================
local Tab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})

-- Section GUN:
Tab:Section({Title = "GUN:"})

-- Silent Aim Toggle
local SilentToggle = Tab:Toggle({
    Title = "Silent Aim | wallbang",
    Desc = "‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏±‡∏ß",
    Default = false,
    Callback = function(state)
        SilentAimEnabled = state
    end
})
myConfig:Register("SilentAim", SilentToggle)

-- FOV Slider
local FOVSlider = Tab:Slider({
    Title = "FOV: ",
    Step = 1,
    Value = {
        Min = 20,
        Max = 750,
        Default = FOV
    },
    Callback = function(value)
        FOV = tonumber(value) or 120
        if SilentFOVCircle then
            if isMobile then
                SilentFOVCircle.Size = UDim2.fromOffset(FOV * 2, FOV * 2)
            else
                SilentFOVCircle.Radius = FOV
            end
        end
    end
})
myConfig:Register("FOVRadius", FOVSlider)

-- Show FOV Toggle
local ShowFOVToggle = Tab:Toggle({
    Title = "Show FOV",
    Desc = "‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏á FOV",
    Default = ShowFOV,
    Callback = function(state)
        ShowFOV = state
        if SilentFOVCircle then
            SilentFOVCircle.Visible = state and SilentAimEnabled
        end
    end
})
myConfig:Register("ShowFOV", ShowFOVToggle)

-- Divider (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤)
Tab:Divider()

-- Safe Friend List Input (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏£)
local FriendsInput = Tab:Input({
    Title = "Sefe Friend List",
    Desc = "Enter Player Name",
    Value = "",
    InputIcon = "shield-check",
    Type = "Input",  -- ‚¨ÖÔ∏è ‡πÉ‡∏ä‡πâ Type = "Input" ‡πÅ‡∏ö‡∏ö‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Å‡πà‡∏≤
    Placeholder = "",
    Callback = function(input)
        excludedPlayerNames = {}
        for name in string.gmatch(input, "%S+") do
            table.insert(excludedPlayerNames, name)
        end
        
        -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ô ESP (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        for _, player in pairs(Players:GetPlayers()) do
            if espPlayers and espPlayers[player] and espPlayers[player].drawings then
                local nameText = espPlayers[player].drawings[1]
                nameText.Color = isPlayerExcluded(player.Name) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
            end
        end
    end
})
myConfig:Register("FriendsList", FriendsInput)

-- =========================
-- Load Config
-- =========================
myConfig:Load()

-- =========================
-- Auto Update Friend List ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
-- =========================
Players.PlayerAdded:Connect(function(player)
    wait(1)
    UpdateExcludedHighlights()
end)

Players.PlayerRemoving:Connect(function(player)
    if excludedPlayersUI[player] then
        excludedPlayersUI[player]:Destroy()
        excludedPlayersUI[player] = nil
    end
end)

-- =========================
-- Notify ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
-- =========================
wait(1)
WindUI:Notify({
    Title = "‚úÖ Silent Aim Loaded",
    Description = "Friend List: " .. table.concat(excludedPlayerNames, ", "),
    Duration = 3
})
